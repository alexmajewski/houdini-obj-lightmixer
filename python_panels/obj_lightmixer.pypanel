<?xml version="1.0" encoding="UTF-8"?>
<pythonPanelDocument>
  <!-- This file contains definitions of Python interfaces and the
 interfaces menu.  It should not be hand-edited when it is being
 used by the application.  Note, that two definitions of the
 same interface or of the interfaces menu are not allowed
 in a single file. -->
  <interface name="obj_lightmixer" label="Obj Context Light Mixer" icon="LOP_lightmixer" showNetworkNavigationBar="false" help_url="">
    <script><![CDATA[#from PySide2 import QtWidgets, QtGui
from PySide2.QtCore import Qt, QRect, QRectF
from PySide2.QtWidgets import QApplication, QToolTip, QFrame, QListWidget, QListWidgetItem, QScrollArea, QRubberBand, QAbstractButton, QGridLayout, QSizePolicy, QSpacerItem, QCheckBox, QPushButton, QWidget, QLabel, QVBoxLayout, QHBoxLayout, QSlider, QHBoxLayout
from PySide2.QtCore import Qt, QMimeData, QSize, QByteArray, QDataStream
from PySide2.QtGui import QDragEnterEvent, QDropEvent, QColor, QPainter, QPen, QBrush, QPainterPath
from PySide2 import QtGui, QtCore

__version__ = "0.2.0"
__author__ = "Alex Majewski"

class SmoothQSlider(QSlider):
    def __init__(self):
        super().__init__()

        self.styles = """
        
        QSlider::groove:vertical {  
            padding-left:-1px;  
            padding-right:-1px;
            padding-top:-1px;  
            padding-bottom:-1px;
            width: 5px;
            border:none;
            background-color: #000;
        }
        QSlider::handle:vertical {
            margin: 0px -10px;
        }
        QSlider::add-page:vertical {
            background: #5A8ABC;
            border-width: 1px;
            border-left-color: #000000;
            border-right-color: #004A98;
            
        }
        QSlider#exposure::add-page:vertical {
            /*margin-bottom:100%;*/
        }
        QSlider#intensity::groove:vertical {
            margin-left:10px;
        }
        QSlider#intensity::add-page:vertical {
            margin-left:10px;
        }
        QSlider::handle:vertical {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                stop:0 #949494,
                stop:1 #767676 
            );
            border-top: 1px solid #B3B3B3;
            border-left: 1px solid #B3B3B3;
            border-bottom: 1px solid #4D4D4D;
            border-right: 1px solid #4D4D4D;
            width: 10px;
            margin: 0px -10px;
            border-radius: 10px;
        }
        QSlider:vertical {
            width: 19px;
            width: 38px;
            margin:0px;
            padding:0px;
            background-color: transparent;
            }
            
        QSlider:horizontal {
            padding-left: 10px;
            padding-right: 10px;
            background: transparent;
            height: 20px;
        } 
        QSlider::groove:horizontal {  
      
        height: 3px;
        border:none;
        background-color: #000;
        }
        QSlider::handle:horizontal {
            margin: -4px 0px;
        }
        QSlider::sub-page:horizontal {
            background: #5A8ABC;
            border-width: 1px;
            border-top-color: #000000;
            border-bottom-color: #004A98;
            
        }
   
        QSlider::handle:horizontal {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                stop:0 #949494,
                stop:1 #767676 
            );
            border-top: 1px solid #B3B3B3;
            border-left: 1px solid #B3B3B3;
            border-bottom: 1px solid #4D4D4D;
            border-right: 1px solid #4D4D4D;
            height: 5px;
            width: 5px;
            border-radius: 10px;
        }
        
        """
        self.setStyleSheet(self.styles)
            
            
    def mousePressEvent(self, event):
        super().mousePressEvent(event)
        self.mouseMoveEvent(event)

    def mouseMoveEvent(self, event):
        if event.buttons() & Qt.LeftButton:
            if self.orientation() == Qt.Vertical:
                new_value = self.maximum() - ((self.maximum() - self.minimum()) * event.y()) / self.height()
            else:
                new_value = self.maximum() - ((self.maximum() - self.minimum()) * (self.width() - event.x())) / self.width()
            self.setValue(new_value)
            new_value = max(self.minimum(), min(new_value, self.maximum())) * 0.01
            new_value = "{:.2f}".format(new_value)
            tooltip_text = f'Value: {new_value}'
            QToolTip.showText(event.globalPos(), tooltip_text, self)
            
            

class LabeledSlider(QWidget):
    def __init__(self, type="intensity"):
        super().__init__()
        
        self.current_min = 0
        self.current_max = 100
        
        self.type = type
        self.tick_labels = []
        
        layout = QGridLayout()
        self.setLayout(layout)
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setAlignment(Qt.AlignCenter)
        
        ticks_layout = QVBoxLayout()
        ticks_layout.setSpacing(0)
        ticks_layout.setContentsMargins(0, 0, 0, 0)
        
        dashticks_layout = QVBoxLayout()
        dashticks_layout.setSpacing(0)
        
        
        
        font_style = "QLabel {font-size: 10px; background-color: transparent;}" 
        
        tick_box_width = 40
        
        tick_amount = 7
        
        # INTENSITY    
        if self.type == "intensity":
        
            dashticks_layout.setContentsMargins(0, 0, 11, 0)
            
            self.slider = SmoothQSlider()
            self.slider.setOrientation(Qt.Vertical)
            unique_style = ("""
                QSlider:vertical {
                    padding-right:2px;
                    margin:0;
                    margin-left: 4px;
                }
                QSlider::groove:vertical {
                    margin-left:16px;
                }
                QSlider::add-page:vertical {
                    margin-left: 16px;
                }
                """)
            self.slider.setStyleSheet(self.slider.styles + unique_style)
        
            inten_max = 100
            inten_min = -9
            inten_step = 25
            # inten_step = int(inten_max / (tick_amount - 1) )
            inten_dash_step = 25
            # inten_dash_step = int( inten_max / (tick_amount * 2 - 1) )
            
            # Styles
            font_layout_style = "QLabel {padding-right: 18px;}"
            
            # Number ticks
            for index, tick_value in enumerate(range(inten_max, inten_min, -inten_step)):
                if inten_min < tick_value < inten_max:
                    spacer = QSpacerItem(10, 10, QSizePolicy.Minimum, QSizePolicy.Expanding)
                    ticks_layout.addItem(spacer)
                self.tick_labels.append(QLabel(str(tick_value)))
                self.tick_labels[index].setStyleSheet(font_layout_style + font_style)
                self.tick_labels[index].setAlignment(Qt.AlignRight)
                ticks_layout.addWidget(self.tick_labels[index])
                
            ticks = QWidget()
            ticks.setStyleSheet("background-color: transparent;")
            ticks.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
            ticks.setFixedWidth(tick_box_width)
            ticks.setLayout(ticks_layout)
            layout.addWidget(ticks, 0, 0, 1, 2)
                
            # Dash ticks
            for tick in range(tick_amount * 2 - 1):
                if 0 < tick < tick_amount*2-1:
                    spacer = QSpacerItem(10, 10, QSizePolicy.Minimum, QSizePolicy.Expanding)
                    dashticks_layout.addItem(spacer)
                tick_dash = QFrame()
                tick_dash.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
                tick_dash.setFixedHeight(10)
                if tick % 3 == 0:
                    tick_dash.setFixedWidth(6)
                else:
                    tick_dash.setFixedWidth(3)
                tick_dash.setStyleSheet("color: #999999;")
                tick_dash.setFrameShape(QFrame.HLine)
                tick_dash.setLineWidth(1)
               
                dashticks_layout.addWidget(tick_dash, alignment=Qt.AlignRight)
            
            dashticks = QWidget()
            dashticks.setStyleSheet("background-color: transparent;")
            dashticks.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
            dashticks.setFixedWidth(tick_box_width)
            dashticks.setLayout(dashticks_layout)
            layout.addWidget(dashticks, 0, 0, 1, 2)
            
            # Slider 
            layout.addWidget(self.slider, 0, 1, 1, 1)
            
        # EXPOSURE ----------------------------
        if self.type == "exposure":
            
            dashticks_layout.setContentsMargins(11, 0, 0, 0)
            font_layout_style = "QLabel {padding-left: 16px;}"
            
            expo_max = int(1.25 *100)
            expo_min = int(-1.25 *100)
            # expo_step = int((expo_max-expo_min)/ (tick_amount - 1) )
            expo_step = int(0.5 * 100)
            
            # Fstop labels ---------------------
            for index, tick_value in enumerate(range(expo_max, expo_min, -expo_step)):
                # add spacers between labels
                if tick_value > expo_min and tick_value < expo_max:
                    spacer = QSpacerItem(10, 10, QSizePolicy.Minimum, QSizePolicy.Expanding)
                    ticks_layout.addItem(spacer)
                
                # round to 0.5
                # dividing by 100 removes the slider multiplier
                final_tick_value = round((tick_value * 0.01) * 2) / 2
                self.tick_labels.append(QLabel(f"Æ{final_tick_value}"))
                self.tick_labels[index].setStyleSheet(font_layout_style + font_style)
                ticks_layout.addWidget(self.tick_labels[index])
               
                
            ticks = QWidget()
            ticks.setStyleSheet("background-color: transparent;")
            ticks.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
            ticks.setFixedWidth(tick_box_width)
            ticks.setLayout(ticks_layout)
            layout.addWidget(ticks, 0, 2, 1, 1)
            
            # Dash ticks
            for tick in range(tick_amount * 2 -1):
                if 0 < tick < tick_amount*2-1:
                    spacer = QSpacerItem(10, 10, QSizePolicy.Minimum, QSizePolicy.Expanding)
                    dashticks_layout.addItem(spacer)
                tick_dash = QFrame()
                tick_dash.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
                tick_dash.setFixedHeight(10)
                if tick % 3 == 0:
                    tick_dash.setFixedWidth(6)
                else:
                    tick_dash.setFixedWidth(3)
                tick_dash.setStyleSheet("color: #999999;")
                tick_dash.setFrameShape(QFrame.HLine)
                tick_dash.setLineWidth(1)
               
                dashticks_layout.addWidget(tick_dash, alignment=Qt.AlignLeft)
                
            dashticks = QWidget()
            dashticks.setStyleSheet("background-color: transparent;")
            dashticks.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
            dashticks.setFixedWidth(tick_box_width)
            dashticks.setLayout(dashticks_layout)
            layout.addWidget(dashticks, 0, 2, 1, 2)
            
            # Slider
            self.slider = SmoothQSlider()
            self.slider.setObjectName("exposure")
            layout.addWidget(self.slider, 0, 2, 1, 1)
            unique_style = ("""
                QSlider:vertical {
                    padding-left:2px;
                    margin:0;
                    margin-right: 5px;
                }
                QSlider::groove:vertical {
                    margin-right:16px;
                }
                QSlider::add-page:vertical {
                    margin-right: 16px;
                }
                """)
            self.slider.setStyleSheet(self.slider.styles + unique_style)
            
    def setTickLabels(self, range_min, range_max, type="intensity"):
        num_steps = len(self.tick_labels)
        
        full_range = range_max - range_min
        step_size = full_range / (num_steps -1)
        
        
        for i in range(num_steps):
            if full_range >= num_steps:
                step_value = int(range_max - step_size * i)
            else:
                step_value = range_max - step_size * i
            if type == "intensity":
                if step_value >= 1000 or step_value <= -1000:
                    step_value /= 1000
                    step_value = f"{step_value:.1f}" if step_value != int(step_value) else str(int(step_value))
                    step_value = f"{step_value}K"
                self.tick_labels[i].setText(str(step_value))
            elif type == "exposure":
                if step_value >= 0:
                    step_value = f"Æ+{step_value}"
                    self.tick_labels[i].setText(str(step_value))
                else:
                    step_value = f"Æ{step_value}"
                    self.tick_labels[i].setText(str(step_value))

    
    def roundToNearest(self, value, roundto):
        return round(value / roundto) * roundto
    
        
    def setSliderRange(self, object, min, max):
        new_min = min * 100
        new_max = max * 100
        object.slider.setRange(new_min, new_max)
        self.current_min = min
        self.current_max = max
        
    def autoSliderRange(self, object, value, type="intensity"):
        # estimate an initial range based off value
        
        if type == "intensity":
            min = 0
            if  0 <= value < 35:
                self.setSliderRange(object, min, 50)
                self.setTickLabels(min, 50, type)
            elif 35 <= value < 75:
                self.setSliderRange(object, min, 100)
                self.setTickLabels(min, 100, type)
            elif 35 <= value < 75:
                self.setSliderRange(object, min, 100)
                self.setTickLabels(min, 100, type)
            elif 75 <= value < 150:
                self.setSliderRange(object, min, 300)
                self.setTickLabels(min, 300, type)
            elif 150 <= value < 500:
                new_max = self.roundToNearest(value+500, 250)
                self.setSliderRange(object, min, new_max)
                self.setSliderRange(object, min, new_max)
                self.setTickLabels(min, new_max, type)
            elif value >= 500:
                new_max = self.roundToNearest(value+1000, 500)
                self.setSliderRange(object, min, new_max)
                self.setSliderRange(object, min, new_max)
                self.setTickLabels(min, new_max, type)
            elif value < 0:
                scale = int(value/2) if int(value/2) < -1 else 1
                new_min = self.roundToNearest(value+(value/2), scale)
                new_max = self.roundToNearest(value-(value/2), scale)
                self.setSliderRange(object, new_min, new_max)
                self.setSliderRange(object, new_min, new_max)
                self.setTickLabels(new_min, new_max, type)
    
            else:
                self.setSliderRange(object, 0, 100)
                self.setTickLabels(0, 100, type)
        elif type == "exposure":
                new_min = self.roundToNearest(value-3, 3)
                new_max = self.roundToNearest(value+3, 3)
                self.setSliderRange(object, new_min, new_max)
                self.setTickLabels(new_min, new_max, type)
        
class Highlight(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.selected = False
        
    def paintEvent(self, event):
        painter = QPainter(self)
        
        if self.isSelected():
            widget_size = self.size()
            highlight_rect = QRectF(0, 0, widget_size.width(), widget_size.height())
            border_color = QBrush(QColor(185, 134, 32))
            border_width = 4
            border_radius = 6
            painter.setPen(QPen(border_color, border_width))
            border_path = QPainterPath()
            border_path.addRoundedRect(highlight_rect, border_radius, border_radius)
            painter.drawPath(border_path)
        else:
            pass
            
    def isSelected(self):
        list = self.parent().parent().parent()
        selected_items = list.selectedItems()

        for item in selected_items:
            assigned_widget = list.itemWidget(item) 
            if self.parent() == assigned_widget:
                self.selected = True
                return True
        self.selected = False
        return False
                

class LightPanelWidget(QWidget):
    def __init__(self, node_path, parent=None):
        super().__init__(parent)
        
        self.node_object = hou.node(node_path)
        
        self.name = self.node_object.name()
        self.type = self.removeSuffix(self.node_object.type().name())

        
        self.monitored_parms = {}
        # self.selected = False
        
        
        self.initUI()
        
        self.addNodeCallbacks()
    
    def initUI(self):
        
        
    
        stack_layout = QGridLayout(self)
        stack_layout.setContentsMargins(0, 0, 0, 0)
        
        panelbg = QWidget()
        panelbg.setObjectName("panelbg")
        stack_layout.addWidget(panelbg,0,0,1,1)
        
        main_layout = QVBoxLayout(self)
        stack_layout.addLayout(main_layout,0,0,1,1)
        
        
        
        
        self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        self.setFixedWidth(90)
        
        main_layout.setSpacing(7)
        main_layout.setContentsMargins(1, 1, 0, 8)
        
        self.setStyleSheet("""
            #panelbg {
            background-color: #373737;
            border: 1px solid #000000;
            border-right: 0px solid #000000;
            
            }
        """)
        
        # Label Light Name
        self.light_label = QLabel(self.name)
        self.light_label.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.light_label.setAlignment(Qt.AlignCenter)
        self.light_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.light_label.setFixedHeight(25)
        self.light_label.setStyleSheet( "background-color: #474747;")
        main_layout.addWidget(self.light_label)
        
        # Toggle Buttons
        toggle_button_style = """
        QPushButton {
            background-color: #4B4B4B;
            border-radius: 8px;
        }
        QPushButton:checked {
            background-color: #292929;
        }

        QPushButton#enable_button:checked {
            border: 2px solid #FCAF3E;
        }
        QPushButton#enable_button:checked:disabled {
            border: 2px solid #4B4B4B;
        }
        QPushButton#mute_button:checked {
            border: 2px solid #F03939;
        }
        QPushButton#solo_button:checked {
            border: 2px solid #F34B7F;
        }
        QPushButton:hover {
            background-color: #939393;
            border-color: #939393;
        }
        QPushButton:checked:hover {
            background-color: #939393;
        }
        QToolTip {
            background-color: #000000;
        }
        QPushButton:pressed {
            background-color: #292929;
        }
        QPushButton:disabled {
            background-color: #3E3E3E;
        }
        """
        
        self.enable_button = QPushButton()
        self.enable_button.setCheckable(True)
        self.enable_button.setChecked(self.node_object.parm("light_enabled").eval())
        self.monitorParmChanges("light_enabled", self.enable_button)
        self.enable_icon = hou.qt.Icon(self.setLightIcon(), 20, 20)
        self.enable_button.setIcon(self.enable_icon)
        self.enable_button.setObjectName("enable_button")
        self.enable_button.setStyleSheet(toggle_button_style)
        self.enable_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.enable_button.setToolTip("Enable/Disable")
        self.enable_button.setFixedSize(50, 24)
        self.enable_button.clicked.connect(lambda: self.setEnabled(self.enable_button.isChecked()))
        main_layout.addWidget(self.enable_button, alignment=Qt.AlignHCenter)
        
        twobuttons_layout = QHBoxLayout()
        twobuttons_layout.setSpacing(4)
        twobuttons_layout.setContentsMargins(4, 0, 4, 0)
        
        mute_button = QPushButton()
        if self.type == "rslight" and self.node_object.parm("light_type").eval() == 3:
            mute_button.clicked.connect(self.resize_dialog)
        else:
            mute_button.setEnabled(False)
        mute_button.setObjectName("mute_button")
        mute_icon = hou.qt.Icon("BUTTONS_bbox_size", 20, 20)
        mute_button.setIcon(mute_icon)
        mute_button.setStyleSheet(toggle_button_style)
        mute_button.setToolTip("Resize")
        mute_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        mute_button.setFixedHeight(24)
        # mute_button.clicked.connect(self.setLightIcon)
        twobuttons_layout.addWidget(mute_button)
        
        self.solo_button = QPushButton()
        self.solo_button.setCheckable(True)
        self.solo_button.setObjectName("solo_button")
        solo_icon = hou.qt.Icon("SCENEGRAPH_solo_enabled", 20, 20)
        self.solo_button.setIcon(solo_icon)
        self.solo_button.setStyleSheet(toggle_button_style)
        self.solo_button.setToolTip("Solo")
        self.solo_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        self.solo_button.setFixedHeight(24)
        parent = self.parent()
        self.solo_button.clicked.connect(lambda: parent.toggleSolo(self, self.node_object))
        twobuttons_layout.addWidget(self.solo_button)
        
        main_layout.addLayout(twobuttons_layout)
        
        # Vertical sliders
        intensity_parm_dict = {
            'rslight' : 'RSL_intensityMultiplier',
            'rslightdome' : 'light_intensity',
            'rslighties' : 'multiplier',
            'rslightportal' : 'Light_Portal1_multiplier',
            'rslightsun' : 'PhysicalSun1_multiplier'            
        }
        
        exposure_parm_dict = {
            'rslight' : 'Light1_exposure',
            'rslightdome' : 'RSL_exposure',
            'rslighties' : 'Light_IES1_exposure',
            'rslightportal' : 'Light_Portal1_exposure',
            'rslightsun' : None  
        }
        intensity_parm = self.node_object.parm(intensity_parm_dict[self.type])
        exposure_parm = self.node_object.parm(exposure_parm_dict[self.type])
        
        
        ranges_layout = QHBoxLayout()
        ranges_layout.setSpacing(1)
        ranges_layout.setContentsMargins(20, 0, 20, 0)
        
        ranges_style = """
            QPushButton {
                border:none;
                background-color: transparent;
            }
            QPushButton:hover {
                background-color: #939393;
            }
        }
        """
        
        intensity_range = QPushButton()
        intensity_icon = hou.qt.Icon("SCENEGRAPH_attr_intensity", 20, 20)
        intensity_range.setIcon(intensity_icon)
        intensity_range.setToolTip("Set intensity range")
        intensity_range.setStyleSheet(ranges_style)
        if intensity_range:
            intensity_range.clicked.connect(self.intensity_dialog)
        else:
            intensity_range.setEnabled(False)
        ranges_layout.addWidget(intensity_range)
        
        exposure_range = QPushButton()
        exposure_icon = hou.qt.Icon("SCENEGRAPH_attr_exposure", 20, 20)
        exposure_range.setIcon(exposure_icon)
        exposure_range.setToolTip("Set exposure range")
        exposure_range.setStyleSheet(ranges_style)
        if exposure_parm:
            exposure_range.clicked.connect(self.exposure_dialog)
        else:
            exposure_range.setEnabled(False)
        ranges_layout.addWidget(exposure_range)
        
        main_layout.addLayout(ranges_layout)
        
        sliders_layout = QHBoxLayout()
        sliders_layout.setSpacing(0)
 
        self.slider_intensity = LabeledSlider(type="intensity")
        self.slider_intensity.setObjectName("intensity")
        self.slider_intensity.setToolTip("Intensity")

        
        if intensity_parm:
            self.intensity_value = intensity_parm.eval()
            self.monitorParmChanges(intensity_parm.name(), self.slider_intensity.slider)
            
            self.slider_intensity.autoSliderRange(self.slider_intensity, self.intensity_value, type="intensity")
            
            self.intensity_value *= 100
            # print("intensity is ", self.intensity_value)
            
            self.slider_intensity.slider.setValue(self.intensity_value)
            self.slider_intensity.slider.valueChanged.connect(lambda: self.updateParameter(intensity_parm, self.slider_intensity.slider.value()/100)) 
        else:
            self.slider_intensity.setEnabled(False)
        
        
        sliders_layout.addWidget(self.slider_intensity)
        
        # -----------------
        
        self.slider_exposure = LabeledSlider(type="exposure")
        self.slider_exposure.setObjectName("exposure")
        self.slider_exposure.setToolTip("Exposure")
        
        
        
        if exposure_parm:
            self.exposure_value = exposure_parm.eval()
            self.monitorParmChanges(exposure_parm.name(), self.slider_exposure.slider)
            
            self.slider_exposure.autoSliderRange(self.slider_exposure, self.exposure_value, type="exposure")
           
            self.exposure_value *= 100
            # print("maximum ", self.slider_exposure.slider.maximum())
            self.slider_exposure.slider.setValue( self.exposure_value )
            self.slider_exposure.slider.valueChanged.connect(lambda: self.updateParameter(exposure_parm, self.slider_exposure.slider.value()/100) )
        else:
            self.slider_exposure.setEnabled(False)
             
        sliders_layout.addWidget(self.slider_exposure)
        
        
        # ------------------
        
        main_layout.addLayout(sliders_layout)
        
        # ------------------
        
        spread_parm = self.node_object.parm("RSL_spread")
        if spread_parm and not spread_parm.isHidden():
            self.slider_spread = SmoothQSlider()
            self.slider_spread.setOrientation(Qt.Horizontal)
            self.slider_spread.setValue(int(spread_parm.eval()*100))
            self.slider_spread.setContentsMargins(5, 0, 5, 0)
            self.slider_spread.setToolTip("Spread")
            self.monitorParmChanges(spread_parm.name(), self.slider_spread)
            
            main_layout.addWidget(self.slider_spread)
            
            spread_parm = self.node_object.parm("RSL_spread")
            self.slider_spread.valueChanged.connect(lambda: self.updateParameter(spread_parm, self.slider_spread.value()/100)) 
             
        if self.node_object.parm("light_colorr"):
            self.color_picker = hou.qt.ColorSwatchButton()
            self.monitorParmChanges("light_colorb", self.color_picker)
            
            if self.node_object.parm("TextureSampler1_color_multiplierr"):
                self.monitorParmChanges("TextureSampler1_color_multiplierr", self.color_picker)
                pass
            self.color_picker.setColor(self.getLightColor())
                
            self.color_picker.setFixedSize(50, 30)
            self.color_picker.setStyleSheet("border: 5px solid #000000;")
            self.color_picker.colorChanged.connect(self.setLightColor)
            main_layout.addWidget(self.color_picker, alignment=Qt.AlignHCenter)
      
        
        self.highlight = Highlight(parent=self)
        self.highlight.setAttribute(Qt.WA_TransparentForMouseEvents)
        stack_layout.addWidget(self.highlight,0,0,1,1)
        
        
    def removeSuffix(self, string):
        split_string = string.split(':')
        return split_string[0]
        
    def setLightIcon(self):
        node_type = self.node_object.type().name()
        light_type = self.node_object.parm("light_type")
        
        if light_type is not None:
            light_types = {
                0: "SCENEGRAPH_spherelight",
                1: "OBJ_light_point",
                2: "SCENEGRAPH_shapedlight",
                3: "SCENEGRAPH_rectlight"
            }
            selected_type = light_type.eval()
            return light_types.get(selected_type, "Unknown")
        elif node_type.startswith("rslightdome"):
            return "SCENEGRAPH_domelight"
        elif node_type.startswith("rslightsun"):
            return "SCENEGRAPH_distantlight"
        elif node_type.startswith("rslightportal"):
            return "SCENEGRAPH_portallight"
        elif node_type.startswith("rslighties"):
            return "SCENEGRAPH_geometrylight"
        else:
            return "SCENEGRAPH_spherelight"
    def updateParameter(self, object, new_value):
        if isinstance(new_value, (float, int)):
            object.set(new_value)
        elif isinstance(new_value, (list, tuple)):
            for i, component in enumerate(new_value):
                object[i].set(component)
    
    def setEnabled(self, value):
        self.node_object.parm("light_enabled").set(int(value))
        
    def getLightColor(self):
        isUseTexture = self.node_object.parm("RSColorLayer1_layer1_enable")
        if isUseTexture:
            if not isUseTexture.eval():
                r = self.node_object.parm("light_colorr").eval() * 255
                g = self.node_object.parm("light_colorg").eval() * 255
                b = self.node_object.parm("light_colorb").eval() * 255
                return QColor(r, g, b)
            else: 
                r = self.node_object.parm("TextureSampler1_color_multiplierr").eval() * 255
                g = self.node_object.parm("TextureSampler1_color_multiplierg").eval() * 255
                b = self.node_object.parm("TextureSampler1_color_multiplierb").eval() * 255
                return QColor(r, g, b)
        else:
            r = self.node_object.parm("light_colorr").eval() * 255
            g = self.node_object.parm("light_colorg").eval() * 255
            b = self.node_object.parm("light_colorb").eval() * 255
            return QColor(r, g, b)
        
    def setLightColor(self):
       
        isUseTexture = self.node_object.parm("RSColorLayer1_layer1_enable")
        
        if isUseTexture:
            if not isUseTexture.eval():
                r = self.color_picker.color().red() / 255
                g = self.color_picker.color().green() / 255
                b = self.color_picker.color().blue() / 255

                final_color = {
                    "light_colorr": r,
                    "light_colorg": g,
                    "light_colorb": b
                }
                self.node_object.setParms(final_color)
            else:
                r = self.color_picker.color().red() / 255
                g = self.color_picker.color().green() / 255
                b = self.color_picker.color().blue() / 255
                
                final_color = {
                    "TextureSampler1_color_multiplierr": r,
                    "TextureSampler1_color_multiplierg": g,
                    "TextureSampler1_color_multiplierb": b
                }
                self.node_object.setParms(final_color)
        else:
            r = self.color_picker.color().red() / 255
            g = self.color_picker.color().green() / 255
            b = self.color_picker.color().blue() / 255

            final_color = {
                "light_colorr": r,
                "light_colorg": g,
                "light_colorb": b
            }
            self.node_object.setParms(final_color)
            
    def intensity_dialog(self):
        labels = ("Min", "Value", "Max")
        buttons = ("OK", "Cancel")
        contents = (str(self.slider_intensity.current_min), str(self.intensity_value * 0.01), str(self.slider_intensity.current_max))
        dialog = hou.ui.readMultiInput("Set intensity value and range.", input_labels=labels, buttons=buttons, close_choice=1, initial_contents=contents, title="Set light intensity")
        if dialog[0] == 0:
            self.slider_intensity.setSliderRange(self.slider_intensity, float(dialog[1][0]), float(dialog[1][2]))
            self.intensity_value = float(dialog[1][1]) *100
            self.slider_intensity.slider.setValue( self.intensity_value )
            
            self.slider_intensity.setTickLabels( int(float(dialog[1][0])), int(float(dialog[1][2])), type="intensity" )
            
    def exposure_dialog(self):
        labels = ("Min", "Value", "Max")
        buttons = ("OK", "Cancel")
        contents = (str(self.slider_exposure.current_min), str(self.exposure_value * 0.01) , str(self.slider_exposure.current_max))
        dialog = hou.ui.readMultiInput("Set exposure value and range.", input_labels=labels, buttons=buttons, close_choice=1, initial_contents=contents,  title="Set light exposure")
        if dialog[0] == 0:
            self.slider_exposure.setSliderRange(self.slider_exposure, float(dialog[1][0]), float(dialog[1][2]))
            self.exposure_value = float(dialog[1][1])*100
            self.slider_exposure.slider.setValue( self.exposure_value )
            
            self.slider_exposure.setTickLabels( int(float(dialog[1][0])), int(float(dialog[1][2])), type="exposure" )
            
    def resize_dialog(self):
        self.lightsize_parms = (self.node_object.parm("areasize1"), self.node_object.parm("areasize2"), self.node_object.parm("areasize3"))
        
            
        #ui
        dialog = hou.qt.Dialog()
        dialog.setWindowTitle("Resize light")
        layout = QVBoxLayout()
        layout.setSpacing(10)
        dialog.setLayout(layout)
        
        label = QLabel("Set light size")
        layout.addWidget(label)
        
        self.transform_input = hou.qt.InputField(hou.qt.InputField.FloatType, 3)
        self.transform_input.setValues((self.lightsize_parms[0].eval(), self.lightsize_parms[1].eval(), self.lightsize_parms[2].eval()))
        self.transform_input.valueChanged.connect(lambda: self.updateParameter(self.lightsize_parms, self.transform_input.values()))

        #self.updateParameter(intensity_parm, self.slider_intensity.slider.value()/100)
        
        layout.addWidget(self.transform_input)
        close_button = QPushButton("Close")
        close_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Maximum)
        close_button.setFixedWidth(100)
        close_button.clicked.connect(lambda: dialog.hide())
        layout.addWidget(close_button, alignment=Qt.AlignCenter)   
        dialog.show()
        
    def addNodeCallbacks(self):
        self.node_object.addEventCallback((hou.nodeEventType.ParmTupleChanged,), self._onNodeParmChange)
        self.node_object.addEventCallback((hou.nodeEventType.NameChanged,), self._onNodeNameChange)
        self.node_object.addEventCallback((hou.nodeEventType.BeingDeleted,), self._onNodeDeletion)
        
    def removeCallbacks(self):
        self.node_object.removeEventCallback((hou.nodeEventType.ParmTupleChanged,), self._onNodeParmChange)
        self.node_object.removeEventCallback((hou.nodeEventType.NameChanged,), self._onNodeNameChange)
        self.node_object.removeEventCallback((hou.nodeEventType.BeingDeleted,), self._onNodeDeletion)
    
    def monitorParmChanges(self, parm, widget):
        self.monitored_parms[parm] = widget
    
    def _onNodeParmChange(self, **kwargs):
        if kwargs["event_type"] == hou.nodeEventType.ParmTupleChanged and kwargs["parm_tuple"] is not None:
            for parm in kwargs["parm_tuple"]:
                parm_name = parm.name()
                if parm_name in self.monitored_parms:
                    widget = self.monitored_parms[parm_name]
                    
                    if isinstance(widget, hou.qt.ColorSwatchButton):
                        self.color_picker.setColor(self.getLightColor())
                        
                    elif isinstance(widget, SmoothQSlider):
                        widget.setValue(self.node_object.parm(parm_name).eval() * 100)
                        
                    elif isinstance(widget, QPushButton):
                        widget.setChecked(self.node_object.parm(parm_name).eval())
                    
        
    def _onNodeNameChange(self, node, **kwargs):
        self.name = node.name()
        if kwargs["event_type"] == hou.nodeEventType.NameChanged:
            self.light_label.setText(self.name)
        
    def _onNodeDeletion(self, **kwargs):
        self.removeSelf()
        
    
    def removeFromMixer(self):
        self.removeCallbacks()
        self.removeSelf()
     
    def removeSelf(self):
        node_id = self.node_object.sessionId()
        
        list = self.parent().parent()
        
        items = list.findItems("", Qt.MatchContains)
           
        for item in items:
            if list.itemWidget(item) == self:
                list.takeItem(list.row(item))
                break
        
        
        
        if node_id in list.light_ids:
            list.light_ids.remove(node_id)

            
        
    

class DropOffArea(QListWidget):
    def __init__(self):
        super().__init__()
        
        # --------
        
        self.light_ids = []
        self.solo_memory = {}
        self.accepted_nodes = ["rslight", "rslightdome", "rslighties", "rslightportal", "rslightsun"]
        self.setMinimumHeight(275)
        self._placeholder_text = "Drag & drop Redshift lights here"
        
        # --------
        
        self.setSelectionMode(QListWidget.ExtendedSelection)
        self.setLayoutMode(QListWidget.SinglePass)
        self.setFlow(QListWidget.LeftToRight)
        self.setDragDropMode(QListWidget.InternalMove)
        self.setStyleSheet("""    
                                QListWidget {
                                background-color: #3A3A3A;
                                }
                                QListWidget::item:selected { 
                                background-color: transparent;
                                }
                                QListWidget::item:hover {
                                background-color: transparent;
                                }
                                """)


        self.setAcceptDrops(True)
        
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Delete:
            self.removeSelectedItems()
        else:
            super().keyPressEvent(event)
            
    def removeSelectedItems(self):
        selected_items = self.selectedItems()
        for item in selected_items:
            widget = self.itemWidget(item)
            widget.removeFromMixer()
            node_id = widget.node_object.sessionId()
            # self.takeItem(self.row(item))

            if node_id in self.light_ids:
                self.light_ids.remove(node_id)
    
    def newListItem(self, path):
        node_path = path
        widget = LightPanelWidget((node_path), parent=self)
        
        
        list_item = QListWidgetItem()
        
        list_item.setSizeHint(QSize(90,100))
        
        self.addItem(list_item)
        self.setItemWidget(list_item, widget)
     
    
    
    def validDropInfo(self, drop_info):
        
        if drop_info.startswith("/obj/"):
            node = hou.node(drop_info)
            node_type = node.type().name()
            if node_type.startswith("rslight"):
                return True
            else:
                print("Unsupported node. Use RSLights only.")
                return False
        else:
            print("Only OBJ context nodes are allowed.")
            return False
            
    # disappearing widgets bug fix
    def dragMoveEvent(self, e):
        mime_data = e.mimeData()
        
        
        if (
            (self.row(self.itemAt(e.pos())) == self.currentRow() + 1)
            or (self.currentRow() == self.count() - 1 and self.row(self.itemAt(e.pos())) == -1)
        ):  
            if e.mimeData().hasFormat('application/x-qabstractitemmodeldatalist'):
                e.ignore()
            else:
                #allow drag and dropping nodes into mixer
                pass
        else:
            super().dragMoveEvent(e)
            
    def dropEvent(self, event: QDropEvent):
        data = event.mimeData()
        if data.hasText():
            drop_info = data.text()
            node_paths = drop_info.split('\t')
            for node_path in node_paths:
                if self.validDropInfo(node_path):
                    node = hou.node(node_path)
                    node_name = node.name()
                    node_type = node.type().name()
                    node_id = node.sessionId()
                    
                    if not self.isListed(node_id): 
                        self.newListItem(node_path)
                        self.light_ids.append(node_id)     
        super().dropEvent(event)
            
    
    @property
    def placeholder_text(self):
        return self._placeholder_text

    @placeholder_text.setter
    def placeholder_text(self, text):
        self._placeholder_text = text
        self.update()
        
    def paintEvent(self, event):
        super().paintEvent(event)
        
        # Draw the placeholder text in the middle of the widget when it's empty
        if self.count() == 0:
            painter = QtGui.QPainter(self.viewport())
            painter.save()
            text_color = QtGui.QColor(127, 127, 127) 
            painter.setPen(text_color)
            
            font = QtGui.QFont()
            font.setPointSize(9)
            painter.setFont(font)
            
            fm = self.fontMetrics()
            elided_text = fm.elidedText(
                self.placeholder_text, QtCore.Qt.ElideRight, self.viewport().width()
            )
            painter.drawText(self.viewport().rect(), QtCore.Qt.AlignCenter, elided_text)
            painter.restore()
    
    def isListed(self, node_id):
        if node_id in self.light_ids:
            return True
        else:
            return False
            
    def unlist(self, node_id):
        if node_id in self.light_ids:
            self.light_ids.remove(node_id)
    

        
    def toggleSolo(self, object, node_object):
        isChecked = object.solo_button.isChecked()
        
        if isChecked:
            if self.solo_memory:
                is_self_memory = True
            else:
                is_self_memory = False
            
            for node in hou.node("/obj").allSubChildren():
                if self.removeSuffix(node.type().name()) in self.accepted_nodes:
                   
                    if node.parm("light_enabled"):
                        parm_value = node.parm("light_enabled").eval()
                        if not is_self_memory:
                            self.solo_memory[node.sessionId()] = parm_value
                        node.parm("light_enabled").set(0)
            node_object.parm("light_enabled").set(1)
        else:
            for key, value in self.solo_memory.items():
                hou.nodeBySessionId(key).parm("light_enabled").set(value)
            self.solo_memory.clear()
        
                
        for light_panel in self.findChildren(LightPanelWidget):

            if light_panel.name != node_object.name():
                light_panel.solo_button.setChecked(False)
   
            if isChecked:
                light_panel.enable_button.setEnabled(False)
                
            else:
                light_panel.enable_button.setEnabled(True)
        
    def removeSuffix(self, string):
        split_string = string.split(':')
        return split_string[0]

            
def createInterface():
     root_widget = QWidget()
     layout = QGridLayout()
     layout.setSpacing(0)
     layout.setContentsMargins(0, 0, 0, 0)
     bg = QWidget()
     bg.setStyleSheet("background-color:red;")
     bg.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
     layout.addWidget(bg, 0,0,1,1)
     layout.addWidget(DropOffArea(),0,0,1,1)
     
     root_widget.setLayout(layout)
     root_widget.setCursor(Qt.ArrowCursor)

     return root_widget
]]></script>
    <includeInPaneTabMenu menu_position="0" create_separator="false"/>
    <includeInToolbarMenu menu_position="109" create_separator="false"/>
    <help><![CDATA[]]></help>
  </interface>
</pythonPanelDocument>
